# Отчет по лабораторной работе №4

## 1. Задачи лабораторной работы

В лабораторной работе необходимо реализовать алгоритм сортировки поразрядной сортировки (radix sort) на GPU с использованием CUDA. Алгоритм должен поддерживать сортировку массивов знаковых и беззнаковых целых чисел типов `int32_t`, `int64_t`, `uint32_t` и `uint64_t`. Также необходимо протестировать реализацию на различных размерах массивов и сравнить производительность с реализацией на CPU.


## 2. Инструкция по запуску

**Требования**: `g++`, `nvcc`.

**Сборка**: `make build`

**Запуск**: `./build/radix_sort`

Программа автоматически генерирует случайные массивы различных размеров и тестирует сортировку для всех поддерживаемых типов данных. Результаты включают проверку корректности сортировки и сравнение времени выполнения на CPU и GPU.


## 3. Пример работы

### Входные данные
Программа генерирует случайные массивы целых чисел для каждого из поддерживаемых типов (`int32_t`, `int64_t`, `uint32_t`, `uint64_t`) и различных размеров (1000, 100000, 5000000, 10000000 элементов).

### Замеры времени

```
Benchmark: int32_t[1000] OK
Time: CPU=0.00020s, GPU=0.00298s | speedup: 0.07x

Benchmark: int64_t[1000] OK
Time: CPU=0.00020s, GPU=0.00501s | speedup: 0.04x

Benchmark: int32_t[100000] OK
Time: CPU=0.03151s, GPU=0.00281s | speedup: 11.23x

Benchmark: int64_t[100000] OK
Time: CPU=0.03266s, GPU=0.00559s | speedup: 5.84x

Benchmark: int32_t[5000000] OK
Time: CPU=2.11872s, GPU=0.04427s | speedup: 47.86x

Benchmark: int64_t[5000000] OK
Time: CPU=2.14947s, GPU=0.09901s | speedup: 21.71x

Benchmark: int32_t[10000000] OK
Time: CPU=4.44050s, GPU=0.07976s | speedup: 55.68x

Benchmark: int64_t[10000000] OK
Time: CPU=4.49431s, GPU=0.17786s | speedup: 25.27x

Benchmark: uint32_t[5000000] OK
Time: CPU=2.19110s, GPU=0.04279s | speedup: 51.21x

Benchmark: uint64_t[5000000] OK
Time: CPU=2.15709s, GPU=0.09751s | speedup: 22.12x
```

### Анализ производительности
На примере обработки массивов различных размеров:

- **Малые массивы (1000 элементов)**: GPU реализация медленнее CPU из-за накладных расходов на запуск ядер и перенос данных. Ускорение составляет всего 0.04-0.07x, что делает CPU версию более эффективной для таких объемов данных.

- **Средние массивы (100000 элементов)**: GPU реализация начинает показывать преимущество. Для `int32_t` ускорение достигает 11.23x, для `int64_t` - 5.84x. Параллелизм GPU начинает компенсировать накладные расходы.

- **Большие массивы (5-10 миллионов элементов)**: GPU реализация демонстрирует значительное ускорение. Для массивов из 5 миллионов элементов ускорение составляет 21-51x в зависимости от типа данных. Для массивов из 10 миллионов элементов ускорение достигает 25-55x.

64-битные типы требуют в 2 раза больше вычислительных операций, отсюда происходит примерно двукратное снижение производительности по сравнению с 32-битными типами. При этом знаковость числа (signed/unsigned) практически не влияет на производительность, так как преобразование знакового бита выполняется за константное время.

Для больших массивов преимущество GPU становится очевидным благодаря массивной параллельной обработке данных. Однако накладные расходы на перенос данных и запуск ядер CUDA делают CPU реализацию более эффективной для малых массивов.


## 4. Выводы

Реализация поразрядной сортировки на GPU с использованием CUDA демонстрирует эффективность для больших объемов данных. Алгоритм использует параллельную обработку битов и эффективную работу с памятью через shared memory для оптимизации доступа. Поддержка как знаковых, так и беззнаковых целых чисел достигается путем инвертирования знакового бита перед сортировкой, что позволяет использовать единый алгоритм для всех типов данных.

Основные преимущества GPU реализации проявляются при работе с массивами размером от нескольких миллионов элементов, где параллелизм позволяет достичь ускорения по сравнению с CPU версией. Для малых массивов накладные расходы на перенос данных и запуск ядер CUDA делают CPU реализацию более эффективной.
